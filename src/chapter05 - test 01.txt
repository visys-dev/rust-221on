У Rust, перший варіант не працює через те, що при передачі значення `x` у змінну `y`, відбувається переміщення власності (ownership). Давайте розглянемо обидва варіанти детальніше.

### 1. Перший варіант:

```rust
fn test_01_01() {
    let x = String::from("Hello world");
    let y = x;  // Тут відбувається переміщення
    println!("{}, {}, test_01_01 success", x, y);
}
```

**Причини, чому не працює:**
- В Rust, коли ви присвоюєте одне значення іншій змінній, як у випадку `let y = x;`, відбувається переміщення (move), а не копіювання. Це означає, що `y` тепер володіє ресурсом (в даному випадку, рядком "Hello world"), а `x` більше не може використовуватися, оскільки його власність була переміщена до `y`.
- Коли ви намагаєтеся вивести `x`, компілятор повідомляє, що `x` більше не доступний, тому що його власність була переміщена.

### 2. Другий варіант:

```rust
fn test_01_03() {
    let x = &String::from("Hello world"); // Створюється посилання
    let y = x; // Тут просто копіюється посилання
    println!("{}, {}, test_01_03 success", x, y);
}
```

**Причини, чому працює:**
- У цьому випадку ви створюєте посилання на `String`, використовуючи `&String::from("Hello world")`. Це означає, що `x` є посиланням на `String`, а не володіє ним.
- Коли ви присвоюєте `y` значення `x`, ви просто копіюєте посилання, а не сам ресурс. Тому `x` і `y` вказують на один і той же об’єкт у пам'яті.
- Обидві змінні можуть бути використані, і код компілюється успішно.

### Підсумок

- У першому випадку відбувається переміщення власності, і ви не можете використовувати `x` після цього.
- У другому випадку, ви використовуєте посилання, тому `x` все ще доступний, і ви можете його вивести без помилок.

Це є важливим аспектом системи управління пам'яттю в Rust, що дозволяє уникати помилок, пов'язаних з дублікацією ресурсів та доступом до них.